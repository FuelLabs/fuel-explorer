scalar Address
scalar AssetId
scalar BlockId
scalar Bytes32
scalar ContractId
scalar HexString
scalar MessageId
scalar Salt
scalar Signature
scalar Tai64Timestamp
scalar TransactionId
scalar TxPointer
scalar U64
scalar UtxoId

##########################################################
## Account
##########################################################

type Balance {
  owner: Address!
  amount: U64!
  assetId: AssetId!
}

type BalanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BalanceEdge!]!

  # A list of nodes.
  nodes: [Balance!]!
}

# An edge in a connection.
type BalanceEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Balance!
}

input BalanceFilterInput {
  # Filter coins based on the `owner` field
  owner: Address!
}

input ExcludeInput {
  # Utxos to exclude from the selection.
  utxos: [UtxoId!]!

  # Messages to exclude from the selection.
  messages: [MessageId!]!
}

##########################################################
## Contract
##########################################################

type Contract {
  id: ContractId!
  bytecode: HexString!
  salt: Salt!
}

type ContractBalance {
  contract: ContractId!
  amount: U64!
  assetId: AssetId!
}

type ContractBalanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ContractBalanceEdge!]!

  # A list of nodes.
  nodes: [ContractBalance!]!
}

# An edge in a connection.
type ContractBalanceEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ContractBalance!
}

input ContractBalanceFilterInput {
  # Filter assets based on the `contractId` field
  contract: ContractId!
}

##########################################################
## Block
##########################################################

type Block {
  id: BlockId!
  header: Header!
  consensus: Consensus!
  transactions: [Transaction!]!
}

type BlockConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BlockEdge!]!

  # A list of nodes.
  nodes: [Block!]!
}

# An edge in a connection.
type BlockEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Block!
}

type Header {
  # Hash of the header
  id: BlockId!

  # The layer 1 height of messages and events to include since the last layer 1 block number.
  daHeight: U64!

  # Number of transactions in this block.
  transactionsCount: U64!

  # Number of output messages in this block.
  outputMessagesCount: U64!

  # Merkle root of transactions.
  transactionsRoot: Bytes32!

  # Merkle root of messages in this block.
  outputMessagesRoot: Bytes32!

  # Fuel block height.
  height: U64!

  # Merkle root of all previous block header hashes.
  prevRoot: Bytes32!

  # The block producer time.
  time: Tai64Timestamp!

  # Hash of the application header.
  applicationHash: Bytes32!
}

##########################################################
## Chain
##########################################################

union Consensus = Genesis | PoAConsensus

type ConsensusParameters {
  contractMaxSize: U64!
  maxInputs: U64!
  maxOutputs: U64!
  maxWitnesses: U64!
  maxGasPerTx: U64!
  maxScriptLength: U64!
  maxScriptDataLength: U64!
  maxStorageSlots: U64!
  maxPredicateLength: U64!
  maxPredicateDataLength: U64!
  gasPriceFactor: U64!
  gasPerByte: U64!
  maxMessageDataLength: U64!
}

type ChainInfo {
  name: String!
  latestBlock: Block!
  baseChainHeight: U64!
  peerCount: Int!
  consensusParameters: ConsensusParameters!
}

type Genesis {
  # The chain configs define what consensus type to use, what settlement layer to use,
  # rules of block validity, etc.
  chainConfigHash: Bytes32!

  # The Binary Merkle Tree root of all genesis coins.
  coinsRoot: Bytes32!

  # The Binary Merkle Tree root of state, balances, contracts code hash of each contract.
  contractsRoot: Bytes32!

  # The Binary Merkle Tree root of all genesis messages.
  messagesRoot: Bytes32!
}

type PoAConsensus {
  # Gets the signature of the block produced by `PoA` consensus.
  signature: Signature!
}

##########################################################
## NodeInfo
##########################################################

type NodeInfo {
  utxoValidation: Boolean!
  vmBacktrace: Boolean!
  minGasPrice: U64!
  maxTx: U64!
  maxDepth: U64!
  nodeVersion: String!
}

##########################################################
## UTXO
##########################################################

# The schema analog of the [`resource::Resource`].
union Resource = Coin | Message

enum CoinStatus {
  UNSPENT
  SPENT
}

type Coin {
  utxoId: UtxoId!
  owner: Address!
  amount: U64!
  assetId: AssetId!
  maturity: U64!
  status: CoinStatus!
  blockCreated: U64!
}

type CoinConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [CoinEdge!]!

  # A list of nodes.
  nodes: [Coin!]!
}

# An edge in a connection.
type CoinEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Coin!
}

input SpendQueryElementInput {
  # Identifier of the asset to spend.
  assetId: AssetId!

  # Target amount for the query.
  amount: U64!

  # The maximum number of currencies for selection.
  max: U64
}

input CoinFilterInput {
  # Returns coins owned by the `owner`.
  owner: Address!

  # Returns coins only with `asset_id`.
  assetId: AssetId
}

##########################################################
## Message
##########################################################

type Message {
  messageId: MessageId!
  amount: U64!
  sender: Address!
  recipient: Address!
  nonce: U64!
  data: HexString!
  daHeight: U64!
  status: MessageStatus!
}

type MessageConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [MessageEdge!]!

  # A list of nodes.
  nodes: [Message!]!
}

# An edge in a connection.
type MessageEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Message!
}

type MessageOutput {
  recipient: Address!
  amount: U64!
}

type MessageProof {
  proofSet: [Bytes32!]!
  proofIndex: U64!
  sender: Address!
  recipient: Address!
  nonce: Bytes32!
  amount: U64!
  data: HexString!
  signature: Signature!
  header: Header!
}

enum MessageStatus {
  UNSPENT
  SPENT
}

##########################################################
## Transaction
##########################################################

type Transaction {
  id: TransactionId!
  inputAssetIds: [AssetId!]
  inputContracts: [Contract!]
  gasPrice: U64
  gasLimit: U64
  maturity: U64
  txPointer: TxPointer
  isScript: Boolean!
  isCreate: Boolean!
  isMint: Boolean!
  inputs: [Input!]
  outputs: [Output!]!
  witnesses: [HexString!]
  receiptsRoot: Bytes32
  status: TransactionStatus
  receipts: [Receipt!]
  script: HexString
  scriptData: HexString
  bytecodeWitnessIndex: Int
  bytecodeLength: U64
  salt: Salt
  storageSlots: [HexString!]

  # Return the transaction bytes using canonical encoding
  rawPayload: HexString!
}

type TransactionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TransactionEdge!]!

  # A list of nodes.
  nodes: [Transaction!]!
}

# An edge in a connection.
type TransactionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Transaction!
}

##########################################################
## Transaction =>> Metadata
##########################################################

type ProgramState {
  returnType: ReturnType!
  data: HexString!
}

type SqueezedOutStatus {
  reason: String!
}

type SubmittedStatus {
  time: Tai64Timestamp!
}

type FailureStatus {
  block: Block!
  time: Tai64Timestamp!
  reason: String!
  programState: ProgramState
}

type SuccessStatus {
  block: Block!
  time: Tai64Timestamp!
  programState: ProgramState
}

input TimeParameters {
  # The time to set on the first block
  startTime: U64!

  # The time interval between subsequent blocks
  blockTimeInterval: U64!
}

union TransactionStatus =
    SubmittedStatus
  | SuccessStatus
  | SqueezedOutStatus
  | FailureStatus

##########################################################
## Transaction =>> Outputs
##########################################################

type ChangeOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

type CoinOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

type ContractCreated {
  contract: Contract!
  stateRoot: Bytes32!
}

type ContractOutput {
  inputIndex: Int!
  balanceRoot: Bytes32!
  stateRoot: Bytes32!
}

type VariableOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

union Output =
    CoinOutput
  | ContractOutput
  | MessageOutput
  | ChangeOutput
  | VariableOutput
  | ContractCreated

##########################################################
## Transaction =>> Inputs
##########################################################

union Input = InputCoin | InputContract | InputMessage

type InputCoin {
  utxoId: UtxoId!
  owner: Address!
  amount: U64!
  assetId: AssetId!
  txPointer: TxPointer!
  witnessIndex: Int!
  maturity: U64!
  predicate: HexString!
  predicateData: HexString!
}

type InputContract {
  utxoId: UtxoId!
  balanceRoot: Bytes32!
  stateRoot: Bytes32!
  txPointer: TxPointer!
  contract: Contract!
}

type InputMessage {
  messageId: MessageId!
  sender: Address!
  recipient: Address!
  amount: U64!
  nonce: U64!
  witnessIndex: Int!
  data: HexString!
  predicate: HexString!
  predicateData: HexString!
}

##########################################################
## Transaction =>> Receipts
##########################################################

type Receipt {
  contract: Contract
  pc: U64
  is: U64
  to: Contract
  toAddress: Address
  amount: U64
  assetId: AssetId
  gas: U64
  param1: U64
  param2: U64
  val: U64
  ptr: U64
  digest: Bytes32
  reason: U64
  ra: U64
  rb: U64
  rc: U64
  rd: U64
  len: U64
  receiptType: ReceiptType!
  rawPayload: HexString!
  result: U64
  gasUsed: U64
  data: HexString
  messageId: MessageId
  sender: Address
  recipient: Address
  nonce: Bytes32
  contractId: ContractId
}

enum ReceiptType {
  CALL
  RETURN
  RETURN_DATA
  PANIC
  REVERT
  LOG
  LOG_DATA
  TRANSFER
  TRANSFER_OUT
  SCRIPT_RESULT
  MESSAGE_OUT
}

enum ReturnType {
  RETURN
  RETURN_DATA
  REVERT
}

##########################################################
## Mutation
##########################################################

type Mutation {
  # Execute a dry-run of the transaction using a fork of current state, no changes are committed.
  dryRun(tx: HexString!, utxoValidation: Boolean): [Receipt!]!

  # Submits transaction to the txpool
  submit(tx: HexString!): Transaction!
  produceBlocks(blocksToProduce: U64!, time: TimeParameters): U64!
}

##########################################################
## Subscription
##########################################################

type Subscription {
  # Returns a stream of status updates for the given transaction id.
  # If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]
  # or [`TransactionStatus::Failed`] the stream will return that and end immediately.
  # If the current status is [`TransactionStatus::Submitted`] this will be returned
  # and the stream will wait for a future update.
  #
  # This stream will wait forever so it's advised to use within a timeout.
  #
  # It is possible for the stream to miss an update if it is polled slower
  # then the updates arrive. In such a case the stream will close without
  # a status. If this occurs the stream can simply be restarted to return
  # the latest status.
  statusChange(
    # The ID of the transaction
    id: TransactionId!
  ): TransactionStatus!
}

##########################################################
## Query
##########################################################

# Information about pagination in a connection
type PageInfo {
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Query {
  balance(
    # address of the owner
    owner: Address!

    # asset_id of the coin
    assetId: AssetId!
  ): Balance!
  balances(
    filter: BalanceFilterInput!
    first: Int
    after: String
    last: Int
    before: String
  ): BalanceConnection!
  block(
    # ID of the block
    id: BlockId

    # Height of the block
    height: U64
  ): Block
  blocks(first: Int, after: String, last: Int, before: String): BlockConnection!
  chain: ChainInfo!
  transaction(
    # The ID of the transaction
    id: TransactionId!
  ): Transaction
  transactions(
    first: Int
    after: String
    last: Int
    before: String
  ): TransactionConnection!
  transactionsByOwner(
    owner: Address!
    first: Int
    after: String
    last: Int
    before: String
  ): TransactionConnection!

  # Returns true when the GraphQL API is serving requests.
  health: Boolean!

  # Gets the coin by `utxo_id`.
  coin(
    # The ID of the coin
    utxoId: UtxoId!
  ): Coin

  # Gets all coins of some `owner` maybe filtered with by `asset_id` per page.
  # It includes `CoinStatus::Spent` and `CoinStatus::Unspent` coins.
  coins(
    filter: CoinFilterInput!
    first: Int
    after: String
    last: Int
    before: String
  ): CoinConnection!
  contract(
    # ID of the Contract
    id: ContractId!
  ): Contract
  contractBalance(contract: ContractId!, asset: AssetId!): ContractBalance!
  contractBalances(
    filter: ContractBalanceFilterInput!
    first: Int
    after: String
    last: Int
    before: String
  ): ContractBalanceConnection!
  nodeInfo: NodeInfo!
  messages(
    # address of the owner
    owner: Address
    first: Int
    after: String
    last: Int
    before: String
  ): MessageConnection!
  messageProof(
    transactionId: TransactionId!
    messageId: MessageId!
  ): MessageProof

  # For each `query_per_asset`, get some spendable resources(of asset specified by the query) owned by
  # `owner` that add up at least the query amount. The returned resources are actual resources
  # that can be spent. The number of resources is optimized to prevent dust accumulation.
  # Max number of resources and excluded resources can also be specified.
  #
  # Returns:
  # The list of spendable resources per asset from the query. The length of the result is
  # the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
  # is the same.
  resourcesToSpend(
    # The `Address` of the resources owner.
    owner: Address!

    # The list of requested assets` resources with asset ids, `target` amount the user wants to reach, and the `max` number of resources in the selection. Several entries with the same asset id are not allowed.
    queryPerAsset: [SpendQueryElementInput!]!

    # The excluded resources from the selection.
    excludedIds: ExcludeInput
  ): [[Resource!]!]!
}
