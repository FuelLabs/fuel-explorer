schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Account {
  address: String!
  name: String!
  url: String
}

scalar Address

scalar AssetId

type Balance {
  amount: U64!
  assetId: AssetId!
  owner: Address!
  utxos: [UtxoItem]
}

type BalanceConnection {
  """A list of edges."""
  edges: [BalanceEdge!]!
  """A list of nodes."""
  nodes: [Balance!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BalanceEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Balance!
}

input BalanceFilterInput {
  """Filter coins based on the `owner` field"""
  owner: Address!
}

type Block {
  consensus: Consensus!
  header: Header!
  id: BlockId!
  producer: Address
  time: ParsedTime
  totalGasUsed: U64
  transactions: [Transaction!]!
}

type BlockConnection {
  """A list of edges."""
  edges: [BlockEdge!]!
  """A list of nodes."""
  nodes: [Block!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BlockEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Block!
}

scalar BlockId

scalar Bytes32

type ChainInfo {
  baseChainHeight: U32!
  consensusParameters: ConsensusParameters!
  gasCosts: GasCosts!
  latestBlock: Block!
  name: String!
  peerCount: Int!
}

type ChangeOutput {
  amount: U64!
  assetId: AssetId!
  to: Address!
}

type Coin {
  amount: U64!
  assetId: AssetId!
  """TxPointer - the height of the block this coin was created in"""
  blockCreated: U32!
  maturity: U32!
  owner: Address!
  """TxPointer - the index of the transaction that created this coin"""
  txCreatedIdx: U64!
  utxoId: UtxoId!
}

type CoinConnection {
  """A list of edges."""
  edges: [CoinEdge!]!
  """A list of nodes."""
  nodes: [Coin!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CoinEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Coin!
}

input CoinFilterInput {
  """Returns coins only with `asset_id`."""
  assetId: AssetId
  """Returns coins owned by the `owner`."""
  owner: Address!
}

type CoinOutput {
  amount: U64!
  assetId: AssetId!
  to: Address!
}

"""The schema analog of the [`coins::CoinType`]."""
union CoinType = Coin | MessageCoin

union Consensus = Genesis | PoAConsensus

type ConsensusParameters {
  chainId: U64!
  contractMaxSize: U64!
  gasPerByte: U64!
  gasPriceFactor: U64!
  maxGasPerPredicate: U64!
  maxGasPerTx: U64!
  maxInputs: U64!
  maxMessageDataLength: U64!
  maxOutputs: U64!
  maxPredicateDataLength: U64!
  maxPredicateLength: U64!
  maxScriptDataLength: U64!
  maxScriptLength: U64!
  maxStorageSlots: U64!
  maxWitnesses: U64!
}

type Contract {
  bytecode: HexString!
  id: ContractId!
  salt: Salt!
}

type ContractBalance {
  amount: U64!
  assetId: AssetId!
  contract: ContractId!
}

type ContractBalanceConnection {
  """A list of edges."""
  edges: [ContractBalanceEdge!]!
  """A list of nodes."""
  nodes: [ContractBalance!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ContractBalanceEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ContractBalance!
}

input ContractBalanceFilterInput {
  """Filter assets based on the `contractId` field"""
  contract: ContractId!
}

type ContractCreated {
  contract: Contract!
  stateRoot: Bytes32!
}

scalar ContractId

type ContractOutput {
  balanceRoot: Bytes32!
  inputIndex: Int!
  stateRoot: Bytes32!
}

type DependentCost {
  base: U64!
  depPerUnit: U64!
}

input ExcludeInput {
  """Messages to exclude from the selection."""
  messages: [Nonce!]!
  """Utxos to exclude from the selection."""
  utxos: [UtxoId!]!
}

type FailureStatus {
  block: Block!
  programState: ProgramState
  reason: String!
  time: Tai64Timestamp!
}

type GasCosts {
  add: U64!
  addi: U64!
  aloc: U64!
  and: U64!
  andi: U64!
  bal: U64!
  bhei: U64!
  bhsh: U64!
  burn: U64!
  call: DependentCost!
  cb: U64!
  ccp: DependentCost!
  cfei: U64!
  cfsi: U64!
  croo: U64!
  csiz: DependentCost!
  div: U64!
  divi: U64!
  eck1: U64!
  ecr1: U64!
  ed19: U64!
  eq: U64!
  exp: U64!
  expi: U64!
  flag: U64!
  gm: U64!
  gt: U64!
  gtf: U64!
  ji: U64!
  jmp: U64!
  jmpb: U64!
  jmpf: U64!
  jne: U64!
  jneb: U64!
  jnef: U64!
  jnei: U64!
  jnzb: U64!
  jnzf: U64!
  jnzi: U64!
  k256: U64!
  lb: U64!
  ldc: DependentCost!
  log: U64!
  logd: DependentCost!
  lt: U64!
  lw: U64!
  mcl: DependentCost!
  mcli: DependentCost!
  mcp: DependentCost!
  mcpi: U64!
  meq: DependentCost!
  mint: U64!
  mldv: U64!
  mlog: U64!
  modOp: U64!
  modi: U64!
  moveOp: U64!
  movi: U64!
  mroo: U64!
  mul: U64!
  muli: U64!
  noop: U64!
  not: U64!
  or: U64!
  ori: U64!
  ret: U64!
  retd: DependentCost!
  rvrt: U64!
  s256: U64!
  sb: U64!
  scwq: U64!
  sll: U64!
  slli: U64!
  smo: DependentCost!
  srl: U64!
  srli: U64!
  srw: U64!
  srwq: DependentCost!
  sub: U64!
  subi: U64!
  sw: U64!
  sww: U64!
  swwq: U64!
  time: U64!
  tr: U64!
  tro: U64!
  wdam: U64!
  wdcm: U64!
  wddv: U64!
  wdmd: U64!
  wdml: U64!
  wdmm: U64!
  wdop: U64!
  wqam: U64!
  wqcm: U64!
  wqdv: U64!
  wqmd: U64!
  wqml: U64!
  wqmm: U64!
  wqop: U64!
  xor: U64!
  xori: U64!
}

type Genesis {
  """
  The chain configs define what consensus type to use, what settlement layer to use,
  rules of block validity, etc.
  """
  chainConfigHash: Bytes32!
  """The Binary Merkle Tree root of all genesis coins."""
  coinsRoot: Bytes32!
  """
  The Binary Merkle Tree root of state, balances, contracts code hash of each contract.
  """
  contractsRoot: Bytes32!
  """The Binary Merkle Tree root of all genesis messages."""
  messagesRoot: Bytes32!
}

type GroupedInput {
  assetId: AssetId
  contractId: ContractId
  data: HexString
  inputs: [Input]
  owner: Address
  recipient: Address
  sender: Address
  totalAmount: U64
  type: GroupedInputType
}

enum GroupedInputType {
  InputCoin
  InputContract
  InputMessage
}

type GroupedOutput {
  assetId: AssetId
  contract: Contract
  inputIndex: Int
  outputs: [Output]
  recipient: Address
  to: Address
  totalAmount: U64
  type: GroupedOutputType
}

enum GroupedOutputType {
  ChangeOutput
  CoinOutput
  ContractCreated
  ContractOutput
  MessageOutput
  VariableOutput
}

type Header {
  """Hash of the application header."""
  applicationHash: Bytes32!
  """
  The layer 1 height of messages and events to include since the last layer 1 block number.
  """
  daHeight: U64!
  """Fuel block height."""
  height: U32!
  """Hash of the header"""
  id: BlockId!
  """Number of message receipts in this block."""
  messageReceiptCount: U64!
  """Merkle root of message receipts in this block."""
  messageReceiptRoot: Bytes32!
  """Merkle root of all previous block header hashes."""
  prevRoot: Bytes32!
  """The block producer time."""
  time: Tai64Timestamp!
  """Number of transactions in this block."""
  transactionsCount: U64!
  """Merkle root of transactions."""
  transactionsRoot: Bytes32!
}

scalar HexString

union Input = InputCoin | InputContract | InputMessage

type InputCoin {
  amount: U64!
  assetId: AssetId!
  maturity: U32!
  owner: Address!
  predicate: HexString!
  predicateData: HexString!
  predicateGasUsed: U64!
  txPointer: TxPointer!
  utxoId: UtxoId!
  witnessIndex: Int!
}

type InputContract {
  balanceRoot: Bytes32!
  contract: Contract!
  stateRoot: Bytes32!
  txPointer: TxPointer!
  utxoId: UtxoId!
}

type InputMessage {
  amount: U64!
  data: HexString!
  nonce: Nonce!
  predicate: HexString!
  predicateData: HexString!
  predicateGasUsed: U64!
  recipient: Address!
  sender: Address!
  witnessIndex: Int!
}

type MerkleProof {
  proofIndex: U64!
  proofSet: [Bytes32!]!
}

type Message {
  amount: U64!
  daHeight: U64!
  data: HexString!
  nonce: Nonce!
  recipient: Address!
  sender: Address!
}

type MessageCoin {
  amount: U64!
  assetId: AssetId!
  daHeight: U64!
  nonce: Nonce!
  recipient: Address!
  sender: Address!
}

type MessageConnection {
  """A list of edges."""
  edges: [MessageEdge!]!
  """A list of nodes."""
  nodes: [Message!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type MessageEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Message!
}

scalar MessageId

type MessageProof {
  amount: U64!
  blockProof: MerkleProof!
  commitBlockHeader: Header!
  data: HexString!
  messageBlockHeader: Header!
  messageProof: MerkleProof!
  nonce: Nonce!
  recipient: Address!
  sender: Address!
}

enum MessageState {
  NOT_FOUND
  SPENT
  UNSPENT
}

type MessageStatus {
  state: MessageState!
}

type Mutation {
  """
  Execute a dry-run of the transaction using a fork of current state, no changes are committed.
  """
  dryRun(tx: HexString!, utxoValidation: Boolean): [Receipt!]!
  """
  Sequentially produces `blocks_to_produce` blocks. The first block starts with
  `start_timestamp`. If the block production in the [`crate::service::Config`] is
  `Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between
  them. The `start_timestamp` is the timestamp in seconds.
  """
  produceBlocks(blocksToProduce: U64!, startTimestamp: Tai64Timestamp): U32!
  """
  Submits transaction to the `TxPool`.
  
  Returns submitted transaction if the transaction is included in the `TxPool` without problems.
  """
  submit(tx: HexString!): Transaction!
}

type NodeInfo {
  maxDepth: U64!
  maxTx: U64!
  minGasPrice: U64!
  nodeVersion: String!
  utxoValidation: Boolean!
  vmBacktrace: Boolean!
}

scalar Nonce

union Output = ChangeOutput | CoinOutput | ContractCreated | ContractOutput | VariableOutput

"""Information about pagination in a connection"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type ParsedTime {
  fromNow: String
  full: String
  rawTai64: String
  rawUnix: String
}

type PoAConsensus {
  """Gets the signature of the block produced by `PoA` consensus."""
  signature: Signature!
}

type ProgramState {
  data: HexString!
  returnType: ReturnType!
}

type Query {
  accounts(addresses: [String]!): [Account!]!
  balance(
    """asset_id of the coin"""
    assetId: AssetId!
    """address of the owner"""
    owner: Address!
  ): Balance!
  balances(after: String, before: String, filter: BalanceFilterInput!, first: Int, last: Int): BalanceConnection!
  block(
    """Height of the block"""
    height: U64
    """ID of the block"""
    id: BlockId
  ): Block
  blocks(after: String, before: String, first: Int, last: Int): BlockConnection!
  chain: ChainInfo!
  """Gets the coin by `utxo_id`."""
  coin(
    """The ID of the coin"""
    utxoId: UtxoId!
  ): Coin
  """
  Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page.
  """
  coins(after: String, before: String, filter: CoinFilterInput!, first: Int, last: Int): CoinConnection!
  """
  For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by
  `owner` that add up at least the query amount. The returned coins can be spent.
  The number of coins is optimized to prevent dust accumulation.
  
  The query supports excluding and maximum the number of coins.
  
  Returns:
  The list of spendable coins per asset from the query. The length of the result is
  the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
  is the same.
  """
  coinsToSpend(
    """The excluded coins from the selection."""
    excludedIds: ExcludeInput
    """The `Address` of the coins owner."""
    owner: Address!
    """
    The list of requested assets` coins with asset ids, `target` amount the user wants to reach, and the `max` number of coins in the selection. Several entries with the same asset id are not allowed.
    """
    queryPerAsset: [SpendQueryElementInput!]!
  ): [[CoinType!]!]!
  contract(
    """ID of the Contract"""
    id: ContractId!
  ): Contract
  contractBalance(asset: AssetId!, contract: ContractId!): ContractBalance!
  contractBalances(after: String, before: String, filter: ContractBalanceFilterInput!, first: Int, last: Int): ContractBalanceConnection!
  """Estimate the predicate gas for the provided transaction"""
  estimatePredicates(tx: HexString!): Transaction!
  """Returns true when the GraphQL API is serving requests."""
  health: Boolean!
  messageProof(commitBlockHeight: U32, commitBlockId: BlockId, messageId: MessageId!, transactionId: TransactionId!): MessageProof
  messageStatus(nonce: Nonce!): MessageStatus!
  messages(
    after: String
    before: String
    first: Int
    last: Int
    """address of the owner"""
    owner: Address
  ): MessageConnection!
  nodeInfo: NodeInfo!
  tokens(assetsId: [String]!): [Token!]!
  transaction(
    """The ID of the transaction"""
    id: TransactionId!
  ): Transaction
  transactions(after: String, before: String, first: Int, last: Int): TransactionConnection!
  transactionsByOwner(after: String, before: String, first: Int, last: Int, owner: Address!): TransactionConnection!
}

type Receipt {
  amount: U64
  assetId: AssetId
  contract: Contract
  contractId: ContractId
  data: HexString
  digest: Bytes32
  gas: U64
  gasUsed: U64
  is: U64
  len: U64
  nonce: Nonce
  param1: U64
  param2: U64
  pc: U64
  ptr: U64
  ra: U64
  rb: U64
  rc: U64
  rd: U64
  reason: U64
  receiptType: ReceiptType!
  recipient: Address
  result: U64
  sender: Address
  subId: Bytes32
  to: Contract
  toAddress: Address
  val: U64
}

enum ReceiptType {
  BURN
  CALL
  LOG
  LOG_DATA
  MESSAGE_OUT
  MINT
  PANIC
  RETURN
  RETURN_DATA
  REVERT
  SCRIPT_RESULT
  TRANSFER
  TRANSFER_OUT
}

enum ReturnType {
  RETURN
  RETURN_DATA
  REVERT
}

scalar Salt

scalar Signature

input SpendQueryElementInput {
  """Target amount for the query."""
  amount: U64!
  """Identifier of the asset to spend."""
  assetId: AssetId!
  """The maximum number of currencies for selection."""
  max: U64
}

type SqueezedOutStatus {
  reason: String!
}

type SubmittedStatus {
  time: Tai64Timestamp!
}

type Subscription {
  """
  Returns a stream of status updates for the given transaction id.
  If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]
  or [`TransactionStatus::Failed`] the stream will return that and end immediately.
  If the current status is [`TransactionStatus::Submitted`] this will be returned
  and the stream will wait for a future update.
  
  This stream will wait forever so it's advised to use within a timeout.
  
  It is possible for the stream to miss an update if it is polled slower
  then the updates arrive. In such a case the stream will close without
  a status. If this occurs the stream can simply be restarted to return
  the latest status.
  """
  statusChange(
    """The ID of the transaction"""
    id: TransactionId!
  ): TransactionStatus!
  """
  Submits transaction to the `TxPool` and await either confirmation or failure.
  """
  submitAndAwait(tx: HexString!): TransactionStatus!
}

type SuccessStatus {
  block: Block!
  programState: ProgramState
  time: Tai64Timestamp!
}

scalar Tai64Timestamp

type Token {
  assetId: String!
  decimals: U64!
  name: String!
  symbol: String!
  totalAssets: U64
  totalSupply: U64
  url: String
}

type Transaction {
  accountsInvolved: [TransactionAccount]
  blockHeight: String
  bytecodeLength: U64
  bytecodeWitnessIndex: Int
  gasLimit: U64
  gasPrice: U64
  gasUsed: U64
  groupedInputs: [GroupedInput]
  groupedOutputs: [GroupedOutput]
  id: TransactionId!
  inputAssetIds: [AssetId!]
  inputContracts: [Contract!]
  inputs: [Input!]
  isCreate: Boolean!
  isMint: Boolean!
  isScript: Boolean!
  maturity: U32
  outputs: [Output!]!
  """Return the transaction bytes using canonical encoding"""
  rawPayload: HexString!
  receipts: [Receipt!]
  receiptsRoot: Bytes32
  salt: Salt
  script: HexString
  scriptData: HexString
  status: TransactionStatus
  statusType: TransactionStatusType
  storageSlots: [HexString!]
  time: ParsedTime
  title: String
  totalAccounts: Int
  totalAssets: Int
  totalOperations: Int
  txPointer: TxPointer
  witnesses: [HexString!]
}

type TransactionAccount {
  id: String
  type: TransactionAccountType
}

enum TransactionAccountType {
  Contract
  Predicate
  Wallet
}

type TransactionConnection {
  accounts: [Account]
  """A list of edges."""
  edges: [TransactionEdge!]!
  """A list of nodes."""
  nodes: [Transaction!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  tokens: [Token]
}

"""An edge in a connection."""
type TransactionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Transaction!
}

scalar TransactionId

union TransactionStatus = FailureStatus | SqueezedOutStatus | SubmittedStatus | SuccessStatus

enum TransactionStatusType {
  Failure
  Submitted
  Success
}

scalar TxPointer

scalar U32

scalar U64

scalar UtxoId

type UtxoItem {
  amount: U64!
  blockCreated: U32
  txCreatedIdx: U64
  utxoId: UtxoId!
}

type VariableOutput {
  amount: U64!
  assetId: AssetId!
  to: Address!
}